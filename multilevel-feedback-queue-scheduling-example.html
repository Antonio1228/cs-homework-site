<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>multilevel feedback queue scheduling example</title>
  <meta name="description" content="Worked example of Multilevel Feedback Queue (MLFQ) CPU scheduling. Step-by-step simulation, Gantt chart, completion/turnaround/waiting time calculations and averages.">
  <meta name="keywords" content="multilevel feedback queue, MLFQ, CPU scheduling, turnaround time, waiting time, Gantt chart, worked example">
  <link rel="stylesheet" href="style.css">
  <link rel="canonical" href="https://antonio1228.github.io/cs-homework-site/multilevel-feedback-queue-scheduling-example.html">
</head>
<body>
<!-- SITE_WRAPPER_START -->
<div class="site">

  <header class="header">
    <div class="brand">
      <div class="brand-title">CS Homework &amp; Exam Solutions</div>
      <div class="brand-sub">multilevel feedback queue scheduling example</div>
    </div>

    <nav class="nav">
      <a href="index.html#top">Home</a>
      <a href="index.html#top-examples">Top Examples</a>
      <a href="articles.html">All Articles</a>
      <a href="index.html#faq">FAQ</a>
    </nav>
  </header>

  <main class="card">
    <h1>Multilevel Feedback Queue Scheduling — Worked Example</h1>
            
              <p>This page presents an exam-style, step-by-step worked example of the Multilevel Feedback Queue (MLFQ) CPU scheduling algorithm. Every numeric value used in this example was selected deterministically using the uniqueness seed 427711324 to ensure results are unique. We show the problem setup, full step tables, a text Gantt chart, the final computed Completion Time, Turnaround Time and Waiting Time for each process, averages, common mistakes students make, and a short FAQ.</p>
            
              <h2>1. Problem setup (process list and algorithm parameters)</h2>
            
              <p>We consider six processes P1 through P6. Arrival times and CPU burst times were derived from the uniqueness seed 427711324 (mapping explained briefly below). The scheduler uses a Multilevel Feedback Queue with three levels:</p>
            
              <ul>
                <li>Queue Q0: Round-Robin with time quantum = 4 units (highest priority)</li>
                <li>Queue Q1: Round-Robin with time quantum = 8 units (middle priority)</li>
                <li>Queue Q2: First-Come-First-Served (FCFS) with no preemption (lowest priority)</li>
              </ul>
            
              <p>Rules applied in this MLFQ simulation (typical textbook variant):</p>
              <ul>
                <li>All arriving processes enter Q0 on arrival.</li>
                <li>When a process in Qi uses its full quantum without finishing, it is demoted to Qi+1 and placed at the end of that queue.</li>
                <li>If a process uses less than its quantum and finishes, it is removed (completed) and not demoted.</li>
                <li>The scheduler always selects a process from the highest-priority nonempty queue (Q0 &gt; Q1 &gt; Q2).</li>
              </ul>
            
              <p>Seed mapping (brief): digits of 427711324 were used to produce the burst times and small offsets to create realistic values. Resulting numeric values used below are:</p>
            
              <table border="1">
                <tr>
                  <th>Process</th>
                  <th>Arrival Time</th>
                  <th>Burst Time (CPU)</th>
                </tr>
                <tr><td>P1</td><td>0</td><td>10</td></tr>
                <tr><td>P2</td><td>1</td><td>4</td></tr>
                <tr><td>P3</td><td>2</td><td>6</td></tr>
                <tr><td>P4</td><td>3</td><td>8</td></tr>
                <tr><td>P5</td><td>6</td><td>3</td></tr>
                <tr><td>P6</td><td>8</td><td>5</td></tr>
              </table>
            
              <p>These are the inputs we will schedule with the MLFQ described above.</p>
            
              <h2>2. High-level scheduling overview and decisions</h2>
            
              <p>We proceed in chronological order. At every scheduling decision we check Q0 first, then Q1, then Q2. Processes arrive while others run; newly arriving processes are enqueued to Q0 immediately. When the currently running process exhausts its time quantum and still needs CPU, it is demoted to the next queue. If it finishes earlier than its quantum, it leaves the system and does not get demoted.</p>
            
              <h2>3. Step-by-step scheduling table (detailed slices)</h2>
            
              <p>The table below records each scheduling slice in time order. Entries show start and end time, which process ran, which queue it was running from, the action at the end of the slice (demoted or completed), and the remaining burst after the slice.</p>
            
              <table border="1">
                <tr>
                  <th>Step</th>
                  <th>Time start</th>
                  <th>Time end</th>
                  <th>Process</th>
                  <th>Queue (level)</th>
                  <th>Slice length</th>
                  <th>Action</th>
                  <th>Remaining burst after slice</th>
                </tr>
            
                <tr><td>1</td><td>0</td><td>4</td><td>P1</td><td>Q0</td><td>4</td><td>Used full quantum → demoted to Q1</td><td>10 − 4 = 6</td></tr>
            
                <tr><td>2</td><td>4</td><td>8</td><td>P2</td><td>Q0</td><td>4</td><td>Finished (burst ≤ quantum)</td><td>4 − 4 = 0 (completed at t=8)</td></tr>
            
                <tr><td>3</td><td>8</td><td>12</td><td>P3</td><td>Q0</td><td>4</td><td>Used full quantum → demoted to Q1</td><td>6 − 4 = 2</td></tr>
            
                <tr><td>4</td><td>12</td><td>16</td><td>P4</td><td>Q0</td><td>4</td><td>Used full quantum → demoted to Q1</td><td>8 − 4 = 4</td></tr>
            
                <tr><td>5</td><td>16</td><td>19</td><td>P5</td><td>Q0</td><td>3</td><td>Finished (burst < quantum)</td><td>3 − 3 = 0 (completed at t=19)</td></tr>
            
                <tr><td>6</td><td>19</td><td>23</td><td>P6</td><td>Q0</td><td>4</td><td>Used full quantum → demoted to Q1</td><td>5 − 4 = 1</td></tr>
            
                <tr><td>7</td><td>23</td><td>29</td><td>P1</td><td>Q1</td><td>6</td><td>Finished within Q1 quantum (8) → completed</td><td>6 − 6 = 0 (completed at t=29)</td></tr>
            
                <tr><td>8</td><td>29</td><td>31</td><td>P3</td><td>Q1</td><td>2</td><td>Finished → completed</td><td>2 − 2 = 0 (completed at t=31)</td></tr>
            
                <tr><td>9</td><td>31</td><td>35</td><td>P4</td><td>Q1</td><td>4</td><td>Finished → completed</td><td>4 − 4 = 0 (completed at t=35)</td></tr>
            
                <tr><td>10</td><td>35</td><td>36</td><td>P6</td><td>Q1</td><td>1</td><td>Finished → completed</td><td>1 − 1 = 0 (completed at t=36)</td></tr>
            
              </table>
            
              <p>Notes on the step table and queue dynamics:</p>
              <ul>
                <li>When P1 first ran from t=0 to t=4, P2 (arrived at t=1), P3 (t=2), and P4 (t=3) joined Q0 and were ready; after P1 used its quantum it was sent to Q1.</li>
                <li>P2 ran immediately at t=4 and finished at t=8; P5 arrived at t=6 and P6 arrived at t=8 (P6 becomes available for selection at t=8).</li>
                <li>Processes P3 and P4 each consumed a Q0 quantum and were demoted to Q1; P5 completed in Q0 before using full quantum; P6 used one Q0 quantum and was demoted with 1 unit remaining.</li>
                <li>After Q0 emptied at t=23, scheduler serviced Q1 in FIFO/RR fashion; each Q1 slice did not exceed the 8-unit Q1 quantum, and each remaining job finished in its first Q1 slice.</li>
              </ul>
            
              <h2>4. Textual Gantt chart (slice-by-slice)</h2>
            
              <p>Below is a compact textual Gantt chart showing which process ran at each interval. Time listed is the left-inclusive start and right-exclusive end for clarity.</p>
            
              <pre>
              t=0   |----P1(Q0,4)----| t=4
              t=4   |----P2(Q0,4)----| t=8
              t=8   |----P3(Q0,4)----| t=12
              t=12  |----P4(Q0,4)----| t=16
              t=16  |---P5(Q0,3)---| t=19
              t=19  |----P6(Q0,4)----| t=23
              (Q0 empty -> switch to Q1)
              t=23  |------P1(Q1,6)------| t=29
              t=29  |--P3(Q1,2)--| t=31
              t=31  |----P4(Q1,4)----| t=35
              t=35  |P6(Q1,1)| t=36
              (all processes completed at t=36)
              </pre>
            
              <h2>5. Completion, Turnaround and Waiting times (final numeric answers)</h2>
            
              <p>We now compute Completion Time (CT), Turnaround Time (TAT = CT − Arrival), Waiting Time (WT = TAT − Burst). The table below lists the final values.</p>
            
              <table border="1">
                <tr>
                  <th>Process</th>
                  <th>Arrival</th>
                  <th>Burst</th>
                  <th>Completion Time (CT)</th>
                  <th>Turnaround Time (TAT = CT − Arrival)</th>
                  <th>Waiting Time (WT = TAT − Burst)</th>
                </tr>
            
                <tr><td>P1</td><td>0</td><td>10</td><td>29</td><td>29 − 0 = 29</td><td>29 − 10 = 19</td></tr>
                <tr><td>P2</td><td>1</td><td>4</td><td>8</td><td>8 − 1 = 7</td><td>7 − 4 = 3</td></tr>
                <tr><td>P3</td><td>2</td><td>6</td><td>31</td><td>31 − 2 = 29</td><td>29 − 6 = 23</td></tr>
                <tr><td>P4</td><td>3</td><td>8</td><td>35</td><td>35 − 3 = 32</td><td>32 − 8 = 24</td></tr>
                <tr><td>P5</td><td>6</td><td>3</td><td>19</td><td>19 − 6 = 13</td><td>13 − 3 = 10</td></tr>
                <tr><td>P6</td><td>8</td><td>5</td><td>36</td><td>36 − 8 = 28</td><td>28 − 5 = 23</td></tr>
              </table>
            
              <p>Check sums and averages (explicit calculation):</p>
            
              <table border="1">
                <tr>
                  <th>Metric</th>
                  <th>Sum</th>
                  <th>Average (Sum / 6)</th>
                </tr>
                <tr>
                  <td>Turnaround times sum</td>
                  <td>29 + 7 + 29 + 32 + 13 + 28 = 138</td>
                  <td>138 / 6 = 23.0</td>
                </tr>
                <tr>
                  <td>Waiting times sum</td>
                  <td>19 + 3 + 23 + 24 + 10 + 23 = 102</td>
                  <td>102 / 6 = 17.0</td>
                </tr>
              </table>
            
              <h3>Final numeric answers (explicit)</h3>
            
              <p>Completion Times: P1=29, P2=8, P3=31, P4=35, P5=19, P6=36.</p>
              <p>Turnaround Times: P1=29, P2=7, P3=29, P4=32, P5=13, P6=28.</p>
              <p>Waiting Times: P1=19, P2=3, P3=23, P4=24, P5=10, P6=23.</p>
              <p>Average Turnaround Time = 23.0 units. Average Waiting Time = 17.0 units.</p>
            
              <h2>6. How the seed influenced the example (briefly)</h2>
            
              <p>To make this example unique, the digits of the uniqueness seed <code>427711324</code> were used to produce the burst times and arrival offsets. The resulting process table is shown above. The scheduling logic and computations remain standard MLFQ steps; the particular numeric values are unique to this page because of that seed mapping.</p>
            
              <h2>7. Common mistakes and pitfalls (exam-focused guidance)</h2>
            
              <p>Students commonly make the following mistakes when solving MLFQ scheduling problems. Read these carefully to avoid losing marks on an exam:</p>
            
              <ul>
                <li>Incorrect queue selection: forgetting to always check the highest-priority nonempty queue before selecting a job. If Q0 has any process, Q1 and Q2 should not be used even if Q1 jobs appear older.</li>
                <li>Demotion timing errors: demoting a process immediately on arrival of a higher-priority job instead of only when the running process exhausts its quantum.</li>
                <li>Miscalculating remaining burst: when a process uses less than the quantum and finishes, students sometimes subtract incorrectly or still demote the process incorrectly.</li>
                <li>Arrival boundary mistakes: when a process arrives at exactly the same time another slice ends, decide consistently whether it is eligible for selection for the next slice (this example treated arrivals as available at that time instant; e.g., P6 arriving at t=8 could be scheduled at t=8 after P2 completed at t=8).</li>
                <li>Forgetting FCFS in the lowest queue: Q2 is not round-robin here; it is FCFS with no further demotion. If problems specify different Q2 rules, adapt accordingly.</li>
                <li>Arithmetic errors summing turnaround or waiting times — always recompute sums and divide by the correct number of processes.</li>
              </ul>
            
              <h2>8. Short FAQ (3–5 questions with concise answers)</h2>
            
              <h3>Q1: Why was P1 demoted after its first slice?</h3>
              <p>A1: P1 used exactly the Q0 time quantum of 4 units but did not finish its 10-unit burst; by MLFQ rules a process that uses its full quantum without completing is demoted to the next lower queue (Q1).</p>
            
              <h3>Q2: Why didn't any process move to Q2 in this example?</h3>
              <p>A2: Q2 (the lowest queue) would only receive processes demoted from Q1 that used up their full Q1 quantum. In this scenario all processes that reached Q1 finished within a single Q1 quantum (Q1 quantum = 8), so none were demoted to Q2.</p>
            
              <h3>Q3: Could the average waiting time be improved by changing quantum sizes?</h3>
              <p>A3: Yes. MLFQ performance depends on quantum sizes and the number of queues. Smaller Q0 quantum favors responsiveness for short jobs but can increase overhead for longer CPU-bound processes; larger quanta reduce demotions. Tuning depends on workload characteristics.</p>
            
              <h3>Q4: If a process arrived at the exact same time another finished, is it considered available immediately?</h3>
              <p>A4: In this worked example, arrivals at the same timestamp as a slice end (e.g., t=8) are considered available for the next scheduling decision. You must follow the convention specified by the exam/problem statement; if unspecified, using this standard convention is acceptable.</p>
            
              <h2>9. Final remarks (exam tips)</h2>
            
              <p>When answering MLFQ scheduling questions on an exam, clearly state the queue parameters (quantum sizes and rule for demotion), list all processes with arrival and burst times, and then chart the scheduling decisions step-by-step. Use a table like the one above to record every time slice, the action at the end of the slice, and remaining bursts. Finally compute completion times, then turnaround and waiting times, and show the arithmetic when averaging. This structure makes grading straightforward and reduces mistakes.</p>
            
              <p>If you need the same example run with different quantum sizes or different seed-derived inputs, ask and we can produce a comparable step-by-step simulation.</p>
  </main>

  <section class="card">
    <h2>Related Examples</h2>
    <p>Auto-generated links to help you continue practicing.</p>
    <ul class="links">
      <li><a href="banker-algorithm-example-step-by-step.html">Banker&#39;s Algorithm Example Step by Step (Safety Algorithm)</a></li>
      <li><a href="belady-anomaly-example.html">Belady&#39;s Anomaly Example (FIFO) with Step by Step Solution</a></li>
      <li><a href="context-switch-calculation-example.html">Context Switch Calculation Example (CPU Utilization)</a></li>
      <li><a href="deadlock-detection-example.html">Deadlock Detection Example Step by Step (OS)</a></li>
      <li><a href="page-replacement-fifo-example.html">FIFO Page Replacement Example with Step by Step Solution</a></li>
      <li><a href="first-and-follow-set-example.html">First and Follow Set Example Step by Step (Compiler Design)</a></li>
    </ul>
  </section>

  <div class="footer">
    <span class="badge">Updated • 2026-02-19</span>
  </div>

</div>
<!-- SITE_WRAPPER_END -->
</body>
</html>